name: Claude XML Viewer Optimizer
on:
  schedule:
    - cron: '*/15 * * * *'  # 15分間隔実行
  workflow_dispatch:
    inputs:
      phase:
        description: '実行フェーズ'
        required: false
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'diagnose'
          - 'optimize'
          - 'validate'
      continue_from:
        description: '継続ポイント'
        required: false
        default: ''

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  TARGET_REPO: '1tokan/xmlviewerfile'
  SOURCE_URL: 'https://1tokan.github.io/xmlviewerfile'
  OUTPUT_DIR: 'optimized'
  MAX_EXECUTION_DAYS: 30

jobs:
  claude-optimizer:
    runs-on: ubuntu-latest
    timeout-minutes: 14
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        npm i -g @anthropic-ai/sdk jsdom prettier
        cat > package.json << 'EOF'
        {"type":"module","dependencies":{"@anthropic-ai/sdk":"^0.25.0","jsdom":"^22.1.0","prettier":"^3.0.0"}}
        EOF
        npm i
    
    - name: Check execution window
      id: check-window
      run: |
        start_date=$(date -d "$(git log --reverse --format="%ai" | head -1)" +%s)
        current_date=$(date +%s)
        days_diff=$(( (current_date - start_date) / 86400 ))
        echo "days_running=$days_diff" >> $GITHUB_OUTPUT
        echo "should_stop=$([[ $days_diff -gt $MAX_EXECUTION_DAYS ]] && echo true || echo false)" >> $GITHUB_OUTPUT
    
    - name: Create optimizer script
      run: |
        cat > optimizer.mjs << 'EOF'
        import Anthropic from '@anthropic-ai/sdk';
        import { JSDOM } from 'jsdom';
        import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
        import { dirname, join } from 'path';
        import { fileURLToPath } from 'url';
        
        const __dirname = dirname(fileURLToPath(import.meta.url));
        const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
        
        class ClaudeOptimizer {
          constructor() {
            this.baseUrl = process.env.SOURCE_URL;
            this.outputDir = process.env.OUTPUT_DIR;
            this.logFile = 'optimization_log.json';
            this.state = this.loadState();
            this.maxTokens = 4096;
          }
        
          loadState() {
            try {
              return existsSync(this.logFile) ? JSON.parse(readFileSync(this.logFile, 'utf8')) : {
                phase: 'diagnose',
                processed: [],
                issues: [],
                optimizations: [],
                iteration: 0,
                lastRun: null
              };
            } catch { return { phase: 'diagnose', processed: [], issues: [], optimizations: [], iteration: 0 }; }
          }
        
          saveState() {
            this.state.lastRun = Date.now();
            writeFileSync(this.logFile, JSON.stringify(this.state, null, 2));
          }
        
          async fetchContent(url) {
            try {
              const response = await fetch(url);
              return response.ok ? await response.text() : null;
            } catch { return null; }
          }
        
          async analyzeCode(content, filename) {
            const prompt = `以下のコードを分析し、最適化が必要な箇所を特定してください：
        
        ファイル: ${filename}
        コード:
        \`\`\`
        ${content.slice(0, 8000)}
        \`\`\`
        
        以下のJSON形式で回答してください：
        {
          "issues": [
            {
              "type": "performance|readability|maintainability|error_handling",
              "description": "問題の説明",
              "location": "行数または関数名",
              "severity": "high|medium|low",
              "solution": "修正方法"
            }
          ],
          "metrics": {
            "codeSize": "文字数",
            "complexity": "複雑度(1-10)",
            "duplicateCode": "重複コード数"
          }
        }`;
        
            try {
              const response = await anthropic.messages.create({
                model: 'claude-3-sonnet-20240229',
                max_tokens: this.maxTokens,
                messages: [{ role: 'user', content: prompt }]
              });
              
              const result = JSON.parse(response.content[0].text);
              return result;
            } catch (error) {
              console.error('分析エラー:', error);
              return { issues: [], metrics: { codeSize: content.length, complexity: 5, duplicateCode: 0 } };
            }
          }
        
          async optimizeCode(content, issues, filename) {
            const prompt = `以下のコードを最適化してください：
        
        ファイル: ${filename}
        問題点: ${JSON.stringify(issues)}
        コード:
        \`\`\`
        ${content.slice(0, 6000)}
        \`\`\`
        
        最適化されたコードのみを出力してください。説明は不要です。`;
        
            try {
              const response = await anthropic.messages.create({
                model: 'claude-3-sonnet-20240229',
                max_tokens: this.maxTokens,
                messages: [{ role: 'user', content: prompt }]
              });
              
              return response.content[0].text.replace(/```[\s\S]*?```/g, (match) => 
                match.replace(/```(?:html|css|javascript|js)?\n?/, '').replace(/\n?```$/, '')
              );
            } catch (error) {
              console.error('最適化エラー:', error);
              return content;
            }
          }
        
          async diagnosePhase() {
            console.log('🔍 診断フェーズ開始');
            const indexContent = await this.fetchContent(`${this.baseUrl}/index.html`);
            if (!indexContent) throw new Error('index.html取得失敗');
        
            const dom = new JSDOM(indexContent);
            const doc = dom.window.document;
            
            // CSS/JSファイル抽出
            const cssFiles = Array.from(doc.querySelectorAll('link[rel="stylesheet"]')).map(link => link.href);
            const jsFiles = Array.from(doc.querySelectorAll('script[src]')).map(script => script.src);
            
            const filesToAnalyze = [
              { name: 'index.html', content: indexContent },
              ...await Promise.all(cssFiles.map(async url => ({
                name: url.split('/').pop(),
                content: await this.fetchContent(url.startsWith('http') ? url : `${this.baseUrl}/${url}`)
              }))),
              ...await Promise.all(jsFiles.map(async url => ({
                name: url.split('/').pop(),
                content: await this.fetchContent(url.startsWith('http') ? url : `${this.baseUrl}/${url}`)
              })))
            ];
        
            for (const file of filesToAnalyze.filter(f => f.content)) {
              if (this.state.processed.includes(file.name)) continue;
              
              console.log(`分析中: ${file.name}`);
              const analysis = await this.analyzeCode(file.content, file.name);
              
              this.state.issues.push({
                file: file.name,
                content: file.content,
                analysis
              });
              
              this.state.processed.push(file.name);
              this.saveState();
            }
        
            this.state.phase = 'optimize';
            console.log(`✅ 診断完了: ${this.state.issues.length}ファイル分析`);
          }
        
          async optimizePhase() {
            console.log('⚡ 最適化フェーズ開始');
            
            if (!existsSync(this.outputDir)) mkdirSync(this.outputDir, { recursive: true });
            
            for (const item of this.state.issues) {
              if (this.state.optimizations.some(o => o.file === item.file)) continue;
              
              const highIssues = item.analysis.issues.filter(i => i.severity === 'high');
              if (highIssues.length === 0) continue;
              
              console.log(`最適化中: ${item.file}`);
              const optimized = await this.optimizeCode(item.content, highIssues, item.file);
              
              const outputPath = join(this.outputDir, item.file);
              writeFileSync(outputPath, optimized);
              
              this.state.optimizations.push({
                file: item.file,
                original: item.content.length,
                optimized: optimized.length,
                reduction: Math.round((1 - optimized.length / item.content.length) * 100),
                timestamp: new Date().toISOString()
              });
              
              this.saveState();
            }
        
            this.state.phase = 'validate';
            console.log(`✅ 最適化完了: ${this.state.optimizations.length}ファイル処理`);
          }
        
          async validatePhase() {
            console.log('🔍 検証フェーズ開始');
            
            const report = {
              timestamp: new Date().toISOString(),
              totalFiles: this.state.optimizations.length,
              totalReduction: this.state.optimizations.reduce((sum, o) => sum + o.reduction, 0) / this.state.optimizations.length,
              issues: this.state.issues.length,
              optimizations: this.state.optimizations
            };
            
            writeFileSync(join(this.outputDir, 'optimization_report.json'), JSON.stringify(report, null, 2));
            
            console.log(`📊 最適化レポート:`);
            console.log(`- 処理ファイル数: ${report.totalFiles}`);
            console.log(`- 平均削減率: ${report.totalReduction.toFixed(1)}%`);
            console.log(`- 検出問題数: ${report.issues}`);
            
            this.state.phase = 'complete';
            this.state.iteration++;
            this.saveState();
          }
        
          async run(phase = 'all') {
            try {
              if (phase === 'all' || phase === 'diagnose') {
                if (this.state.phase === 'diagnose') await this.diagnosePhase();
              }
              
              if (phase === 'all' || phase === 'optimize') {
                if (this.state.phase === 'optimize') await this.optimizePhase();
              }
              
              if (phase === 'all' || phase === 'validate') {
                if (this.state.phase === 'validate') await this.validatePhase();
              }
              
              if (this.state.phase === 'complete') {
                console.log('🎉 最適化サイクル完了');
                this.state.phase = 'diagnose';
                this.state.processed = [];
                this.saveState();
              }
            } catch (error) {
              console.error('実行エラー:', error);
              process.exit(1);
            }
          }
        }
        
        const optimizer = new ClaudeOptimizer();
        await optimizer.run(process.argv[2] || 'all');
        EOF
    
    - name: Execute optimization
      if: steps.check-window.outputs.should_stop == 'false'
      run: |
        node optimizer.mjs ${{ github.event.inputs.phase || 'all' }}
    
    - name: Commit and push optimizations
      if: steps.check-window.outputs.should_stop == 'false'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        
        if ! git diff --cached --quiet; then
          git commit -m "🚀 Claude最適化 - Iteration ${{ github.run_number }}"
          git push
        else
          echo "変更なし - コミットスキップ"
        fi
    
    - name: Create optimization summary
      if: steps.check-window.outputs.should_stop == 'false'
      run: |
        if [ -f optimization_log.json ]; then
          echo "## 🎯 最適化サマリー" >> $GITHUB_STEP_SUMMARY
          echo "- 実行日時: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- 実行日数: ${{ steps.check-window.outputs.days_running }}日" >> $GITHUB_STEP_SUMMARY
          
          if [ -f optimized/optimization_report.json ]; then
            echo "- 最適化ファイル数: $(jq '.totalFiles' optimized/optimization_report.json)" >> $GITHUB_STEP_SUMMARY
            echo "- 平均削減率: $(jq '.totalReduction' optimized/optimization_report.json)%" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- 処理フェーズ: $(jq -r '.phase' optimization_log.json)" >> $GITHUB_STEP_SUMMARY
          echo "- 反復回数: $(jq '.iteration' optimization_log.json)" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Stop execution after 30 days
      if: steps.check-window.outputs.should_stop == 'true'
      run: |
        echo "⏰ 30日間の実行期間が終了しました"
        echo "最終レポートを生成します"
        
        if [ -f optimized/optimization_report.json ]; then
          echo "## 📊 最終最適化レポート" >> $GITHUB_STEP_SUMMARY
          echo "- 総実行期間: ${{ steps.check-window.outputs.days_running }}日" >> $GITHUB_STEP_SUMMARY
          echo "- 最適化完了ファイル数: $(jq '.totalFiles' optimized/optimization_report.json)" >> $GITHUB_STEP_SUMMARY
          echo "- 平均コード削減率: $(jq '.totalReduction' optimized/optimization_report.json)%" >> $GITHUB_STEP_SUMMARY
          
          # 最適化されたファイルのリストを表示
          echo "### 最適化されたファイル:" >> $GITHUB_STEP_SUMMARY
          jq -r '.optimizations[] | "- \(.file): \(.reduction)% 削減"' optimized/optimization_report.json >> $GITHUB_STEP_SUMMARY
        fi
        
        # ワークフロー自動停止
        gh workflow disable "Claude XML Viewer Optimizer" --repo ${{ github.repository }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
