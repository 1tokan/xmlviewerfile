name: XML Viewer Optimization with Claude

on:
  schedule:
    # 15分ごとに実行（30日間）
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      force_optimization:
        description: 'Force optimization even if no changes detected'
        required: false
        default: 'false'
        type: boolean

env:
  TARGET_REPO: "1tokan/xmlviewerfile"
  TARGET_FOLDER: "main/CALS_EC"
  OPTIMIZED_FOLDER: "optimized"
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

jobs:
  optimize-xml-viewer:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm init -y
          npm install axios fs-extra path cheerio

      - name: Check workflow duration limit
        id: check_duration
        run: |
          # 30日間の制限をチェック
          START_DATE=$(date -d "30 days ago" +%s)
          CURRENT_DATE=$(date +%s)
          
          # 最初の実行日をファイルに記録
          if [ ! -f ".workflow_start" ]; then
            echo $CURRENT_DATE > .workflow_start
          fi
          
          WORKFLOW_START=$(cat .workflow_start)
          ELAPSED_DAYS=$(( ($CURRENT_DATE - $WORKFLOW_START) / 86400 ))
          
          echo "elapsed_days=$ELAPSED_DAYS" >> $GITHUB_OUTPUT
          
          if [ $ELAPSED_DAYS -gt 30 ]; then
            echo "30日間の制限に達しました。ワークフローを停止します。"
            echo "should_stop=true" >> $GITHUB_OUTPUT
          else
            echo "should_stop=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop if duration limit reached
        if: steps.check_duration.outputs.should_stop == 'true'
        run: |
          echo "30日間の実行制限に達したため、ワークフローを停止します。"
          exit 0

      - name: Create optimization script
        run: |
          cat > optimize.js << 'EOF'
          const fs = require('fs-extra');
          const path = require('path');
          const axios = require('axios');
          const cheerio = require('cheerio');

          class XMLViewerOptimizer {
            constructor() {
              this.apiKey = process.env.ANTHROPIC_API_KEY;
              this.targetFolder = 'main/CALS_EC';
              this.optimizedFolder = 'optimized';
              this.logFile = 'optimization_log.json';
              this.stateFile = 'optimization_state.json';
            }

            async initialize() {
              // 最適化フォルダの作成
              await fs.ensureDir(this.optimizedFolder);
              
              // ログファイルの初期化
              if (!await fs.pathExists(this.logFile)) {
                await fs.writeJson(this.logFile, { runs: [] });
              }
              
              // 状態ファイルの初期化
              if (!await fs.pathExists(this.stateFile)) {
                await fs.writeJson(this.stateFile, { 
                  lastRun: null, 
                  processingState: 'complete',
                  currentFile: null,
                  partNumber: 0
                });
              }
            }

            async callClaude(prompt, maxTokens = 4000) {
              try {
                const response = await axios.post('https://api.anthropic.com/v1/messages', {
                  model: 'claude-3-sonnet-20240229',
                  max_tokens: maxTokens,
                  messages: [{
                    role: 'user',
                    content: prompt
                  }]
                }, {
                  headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': this.apiKey,
                    'anthropic-version': '2023-06-01'
                  }
                });

                return response.data.content[0].text;
              } catch (error) {
                console.error('Claude API Error:', error.response?.data || error.message);
                throw error;
              }
            }

            async readSourceFiles() {
              const files = {
                html: null,
                css: null,
                js: null
              };

              try {
                // index.htmlを読み込み
                const htmlPath = path.join(this.targetFolder, 'index.html');
                if (await fs.pathExists(htmlPath)) {
                  files.html = await fs.readFile(htmlPath, 'utf8');
                }

                // CSS/JSファイルを検索
                const cssPath = path.join(this.targetFolder, 'style.css');
                if (await fs.pathExists(cssPath)) {
                  files.css = await fs.readFile(cssPath, 'utf8');
                }

                const jsPath = path.join(this.targetFolder, 'script.js');
                if (await fs.pathExists(jsPath)) {
                  files.js = await fs.readFile(jsPath, 'utf8');
                }

                return files;
              } catch (error) {
                console.error('ファイル読み込みエラー:', error);
                return files;
              }
            }

            async optimizeHTML(htmlContent) {
              const prompt = `
              以下のHTMLを最適化してください：

              要件：
              1. XMLビューワとしての機能を完全に保持
              2. CALS_ECフォルダ以外も選択可能な設計
              3. 不要なコメントや空白を削除
              4. セマンティックHTMLの使用
              5. アクセシビリティの向上

              HTML:
              ${htmlContent}

              最適化されたHTMLコードのみを出力してください。
              `;

              return await this.callClaude(prompt);
            }

            async optimizeCSS(cssContent) {
              const prompt = `
              以下のCSSを最適化してください：

              要件：
              1. 冗長なスタイルの削除
              2. セレクタの最適化
              3. 現代的なCSS技術の活用
              4. 保守性の向上
              5. 必要に応じて機能単位で分割

              CSS:
              ${cssContent}

              最適化されたCSSコードまたは分割されたCSSファイルの構成を出力してください。
              分割する場合は、各ファイルの名前と内容を明示してください。
              `;

              return await this.callClaude(prompt);
            }

            async optimizeJS(jsContent, partNumber = 0) {
              const prompt = `
              以下のJavaScriptを最適化してください：

              要件：
              1. 機能単位での分割（必要に応じて）
              2. 冗長なコードの削除
              3. エラーハンドリングの強化
              4. XMLエラー対応の改善
              5. 保守性と速度の両立
              6. ファイル名はkebab-case/camelCaseで意味のある名前

              ${partNumber > 0 ? `これは${partNumber}番目のパートです。` : ''}

              JavaScript:
              ${jsContent}

              最適化されたJavaScriptコードまたは分割されたJSファイルの構成を出力してください。
              分割する場合は、各ファイルの名前と内容を明示してください。
              `;

              return await this.callClaude(prompt, 4000);
            }

            async processOptimization() {
              const startTime = Date.now();
              const state = await fs.readJson(this.stateFile);
              
              console.log('最適化処理を開始...');
              
              // ソースファイルの読み込み
              const sourceFiles = await this.readSourceFiles();
              
              if (!sourceFiles.html) {
                console.log('index.htmlが見つかりません。処理をスキップします。');
                return;
              }

              let optimizedFiles = {};
              
              try {
                // HTML最適化
                if (state.processingState === 'complete' || state.currentFile === 'html') {
                  console.log('HTML最適化中...');
                  optimizedFiles.html = await this.optimizeHTML(sourceFiles.html);
                  state.currentFile = 'css';
                  await fs.writeJson(this.stateFile, state);
                }

                // CSS最適化
                if (sourceFiles.css && (state.currentFile === 'css')) {
                  console.log('CSS最適化中...');
                  optimizedFiles.css = await this.optimizeCSS(sourceFiles.css);
                  state.currentFile = 'js';
                  await fs.writeJson(this.stateFile, state);
                }

                // JavaScript最適化
                if (sourceFiles.js && (state.currentFile === 'js')) {
                  console.log('JavaScript最適化中...');
                  optimizedFiles.js = await this.optimizeJS(sourceFiles.js, state.partNumber);
                  state.currentFile = 'complete';
                  state.partNumber = 0;
                  await fs.writeJson(this.stateFile, state);
                }

                // 最適化ファイルの保存
                await this.saveOptimizedFiles(optimizedFiles);

                // 処理完了の記録
                const endTime = Date.now();
                const processingTime = endTime - startTime;
                
                await this.logOptimization({
                  timestamp: new Date().toISOString(),
                  processingTime,
                  filesProcessed: Object.keys(optimizedFiles),
                  success: true
                });

                console.log(`最適化完了 (処理時間: ${processingTime}ms)`);
                
                // 状態リセット
                state.processingState = 'complete';
                state.currentFile = null;
                state.lastRun = new Date().toISOString();
                await fs.writeJson(this.stateFile, state);

              } catch (error) {
                console.error('最適化エラー:', error);
                
                // エラーログの記録
                await this.logOptimization({
                  timestamp: new Date().toISOString(),
                  error: error.message,
                  success: false
                });

                // 継続可能な状態の保存
                state.processingState = 'error';
                await fs.writeJson(this.stateFile, state);
              }
            }

            async saveOptimizedFiles(optimizedFiles) {
              for (const [fileType, content] of Object.entries(optimizedFiles)) {
                if (content) {
                  // 分割されたファイルの処理
                  if (content.includes('ファイル名:') || content.includes('File:')) {
                    // 複数ファイルの場合の処理
                    await this.processSplitFiles(content, fileType);
                  } else {
                    // 単一ファイルの保存
                    const fileName = fileType === 'html' ? 'index.html' : 
                                   fileType === 'css' ? 'style.css' : 'script.js';
                    const filePath = path.join(this.optimizedFolder, fileName);
                    await fs.writeFile(filePath, content);
                  }
                }
              }
            }

            async processSplitFiles(content, fileType) {
              // 分割されたファイルの解析と保存
              const files = this.parseSplitFiles(content);
              
              for (const file of files) {
                const filePath = path.join(this.optimizedFolder, file.name);
                await fs.writeFile(filePath, file.content);
              }
            }

            parseSplitFiles(content) {
              // Claude出力から分割されたファイルを解析
              const files = [];
              const lines = content.split('\n');
              let currentFile = null;
              let currentContent = [];

              for (const line of lines) {
                if (line.includes('ファイル名:') || line.includes('File:')) {
                  if (currentFile) {
                    files.push({
                      name: currentFile,
                      content: currentContent.join('\n')
                    });
                  }
                  currentFile = line.split(':')[1].trim();
                  currentContent = [];
                } else if (currentFile && line.trim()) {
                  currentContent.push(line);
                }
              }

              if (currentFile) {
                files.push({
                  name: currentFile,
                  content: currentContent.join('\n')
                });
              }

              return files;
            }

            async logOptimization(logEntry) {
              const log = await fs.readJson(this.logFile);
              log.runs.push(logEntry);
              
              // 最新100件のログを保持
              if (log.runs.length > 100) {
                log.runs = log.runs.slice(-100);
              }
              
              await fs.writeJson(this.logFile, log);
            }

            async run() {
              await this.initialize();
              await this.processOptimization();
            }
          }

          // 実行
          const optimizer = new XMLViewerOptimizer();
          optimizer.run().catch(console.error);
          EOF

      - name: Run optimization
        run: |
          node optimize.js
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Check for changes
        id: check_changes
        run: |
          if [ -d "optimized" ] && [ "$(ls -A optimized)" ]; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit optimized files
        if: steps.check_changes.outputs.changes_detected == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git add optimized/ optimization_log.json optimization_state.json .workflow_start
          
          if ! git diff --cached --quiet; then
            git commit -m "Auto-optimize XML viewer files - $(date '+%Y-%m-%d %H:%M:%S')"
            git push
          else
            echo "変更がありません"
          fi

      - name: Create optimization report
        if: steps.check_changes.outputs.changes_detected == 'true'
        run: |
          cat > optimization_report.md << 'EOF'
          # XML Viewer Optimization Report

          ## 実行時間
          $(date '+%Y-%m-%d %H:%M:%S')

          ## 処理されたファイル
          $(ls -la optimized/ 2>/dev/null || echo "最適化ファイルなし")

          ## ログ
          $(tail -20 optimization_log.json 2>/dev/null || echo "ログなし")

          ## 状態
          $(cat optimization_state.json 2>/dev/null || echo "状態ファイルなし")
          EOF

          echo "## 最適化レポート" >> $GITHUB_STEP_SUMMARY
          cat optimization_report.md >> $GITHUB_STEP_SUMMARY

      - name: Handle errors
        if: failure()
        run: |
          echo "最適化処理でエラーが発生しました。" >> $GITHUB_STEP_SUMMARY
          echo "詳細はログを確認してください。" >> $GITHUB_STEP_SUMMARY
          
          # 状態ファイルをリセット
          if [ -f "optimization_state.json" ]; then
            echo '{"processingState": "error", "lastError": "'$(date)'"}' > optimization_state.json
          fi