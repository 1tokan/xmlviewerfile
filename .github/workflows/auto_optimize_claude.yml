name: Auto Optimize with Claude
on:
  schedule:
    - cron: '*/15 * * * *'  # 15åˆ†ã”ã¨å®Ÿè¡Œ
  workflow_dispatch:
  push:
    paths: ['index.html', '*.css', '*.js']

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  MAX_EXECUTION_DAYS: 30

jobs:
  optimize:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Check execution time limit
      id: time_check
      run: |
        START_TIME=$(git log --format=%ct -n 1 -- .github/workflows/auto_optimize_claude.yml 2>/dev/null || echo $(date +%s))
        CURRENT_TIME=$(date +%s)
        ELAPSED_DAYS=$(( (CURRENT_TIME - START_TIME) / 86400 ))
        
        if [ $ELAPSED_DAYS -gt $MAX_EXECUTION_DAYS ]; then
          echo "execution_expired=true" >> $GITHUB_OUTPUT
          echo "â° æœ€å¤§å®Ÿè¡ŒæœŸé–“($MAX_EXECUTION_DAYSæ—¥)ã‚’è¶…éã—ã¾ã—ãŸ"
          exit 1
        fi
        echo "elapsed_days=$ELAPSED_DAYS" >> $GITHUB_OUTPUT
    
    - name: Install dependencies
      run: |
        npm init -y
        npm install axios cheerio fs-extra
    
    - name: Create optimization script
      run: |
        cat > optimize.js << 'EOF'
        const axios = require('axios');
        const cheerio = require('cheerio');
        const fs = require('fs-extra');
        const path = require('path');
        
        class ClaudeOptimizer {
          constructor() {
            this.apiKey = process.env.ANTHROPIC_API_KEY;
            this.baseUrl = 'https://api.anthropic.com/v1/messages';
            this.optimizationLog = [];
            this.processedFiles = new Set();
            this.targetDir = 'optimized';
            this.maxRetries = 3;
          }
        
          async callClaude(prompt, context = '') {
            const fullPrompt = `${context}\n\n${prompt}`;
            
            for (let i = 0; i < this.maxRetries; i++) {
              try {
                const response = await axios.post(this.baseUrl, {
                  model: 'claude-3-5-sonnet-20241022',
                  max_tokens: 8000,
                  temperature: 0.1,
                  system: `ã‚ãªãŸã¯é«˜åº¦ãªWebãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–å°‚é–€å®¶ã§ã™ã€‚HTML/CSS/JavaScriptã‚³ãƒ¼ãƒ‰ã‚’åˆ†æã—ã€å…·ä½“çš„ãªå•é¡Œç‚¹ã‚’ç‰¹å®šã—ã¦æœ€é©åŒ–ã‚’è¡Œã„ã¾ã™ã€‚å‡¦ç†é€Ÿåº¦ãƒ»ä»•æ§˜å®Œå…¨ç¶²ç¾…ãƒ»æ–‡å­—æ•°æœ€å°åŒ–ã‚’é‡è¦–ã—ã€æ®µéšçš„ãªæœ€é©åŒ–ã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„ã€‚`,
                  messages: [{ role: 'user', content: fullPrompt }]
                }, {
                  headers: {
                    'Authorization': `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                    'anthropic-version': '2023-06-01'
                  },
                  timeout: 30000
                });
                
                return response.data.content[0].text;
              } catch (error) {
                console.log(`Claude APIå‘¼ã³å‡ºã—å¤±æ•— (è©¦è¡Œ ${i + 1}/${this.maxRetries}):`, error.message);
                if (i === this.maxRetries - 1) throw error;
                await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
              }
            }
          }
        
          async analyzeCode(filePath) {
            const startTime = Date.now();
            const content = await fs.readFile(filePath, 'utf8');
            const fileType = path.extname(filePath);
            
            console.log(`ğŸ“‹ åˆ†æé–‹å§‹: ${filePath}`);
            
            const analysisPrompt = `
        ## ã‚³ãƒ¼ãƒ‰è¨ºæ–­ãƒ•ã‚§ãƒ¼ã‚º
        ä»¥ä¸‹ã®${fileType}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†æã—ã€å•é¡Œç‚¹ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ï¼š
        
        **ãƒ•ã‚¡ã‚¤ãƒ«å:** ${filePath}
        **å†…å®¹:**
        \`\`\`${fileType.slice(1)}
        ${content}
        \`\`\`
        
        **åˆ†æè¦³ç‚¹:**
        1. ä¸é©åˆ‡ãƒ»éåŠ¹ç‡ãªè¨˜è¿°
        2. é‡è¤‡ãƒ»æœªä½¿ç”¨ã‚³ãƒ¼ãƒ‰
        3. UX/UIã‚„å‡¦ç†é€Ÿåº¦ã«æ‚ªå½±éŸ¿ã‚’ä¸ãˆã‚‹è¨˜è¿°
        4. å¯èª­æ€§ãƒ»ä¿å®ˆæ€§ã®ä½ã„æ§‹æˆ
        5. è¨­è¨ˆåŸå‰‡ã«åã™ã‚‹ç‚¹
        
        **å‡ºåŠ›å½¢å¼:**
        - å•é¡Œç®‡æ‰€: [è¡Œæ•°] å…·ä½“çš„ãªå•é¡Œç‚¹
        - ä¿®æ­£ç†ç”±: ãªãœä¿®æ­£ãŒå¿…è¦ã‹
        - æœ€é©åŒ–å¯¾è±¡: true/false
        - æ”¹å–„æ¡ˆ: å…·ä½“çš„ãªä¿®æ­£æ–¹æ³•
        
        å•é¡Œã®ãªã„éƒ¨åˆ†ã¯è§¦ã‚‰ãªã„ã“ã¨ã€‚
        `;
            
            const analysis = await this.callClaude(analysisPrompt);
            const processingTime = Date.now() - startTime;
            
            this.optimizationLog.push({
              phase: 'analysis',
              file: filePath,
              processingTime,
              result: analysis,
              timestamp: new Date().toISOString()
            });
            
            return analysis;
          }
        
          async optimizeCode(filePath, analysisResult) {
            const startTime = Date.now();
            const content = await fs.readFile(filePath, 'utf8');
            const fileType = path.extname(filePath);
            
            console.log(`âš¡ æœ€é©åŒ–é–‹å§‹: ${filePath}`);
            
            const optimizationPrompt = `
        ## æœ€é©åŒ–ãƒ•ã‚§ãƒ¼ã‚º
        
        **åˆ†æçµæœ:**
        ${analysisResult}
        
        **å…ƒã®ã‚³ãƒ¼ãƒ‰:**
        \`\`\`${fileType.slice(1)}
        ${content}
        \`\`\`
        
        **æœ€é©åŒ–è¦ä»¶:**
        - å‡¦ç†é€Ÿåº¦: DOMæ“ä½œãƒ»å†æç”»ã®æŠ‘åˆ¶ã€ãƒ«ãƒ¼ãƒ—ã‚„ã‚»ãƒ¬ã‚¯ã‚¿ã®è¦‹ç›´ã—
        - ã‚³ãƒ¼ãƒ‰ç°¡ç´ åŒ–: å†—é•·ãªãƒ­ã‚¸ãƒƒã‚¯ãƒ»æœªä½¿ç”¨å¤‰æ•°ã®å‰Šé™¤
        - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°: try-catchå°å…¥ã€æ§‹æ–‡ãƒ»æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼å¯¾å‡¦
        - ä¿å®ˆæ€§: å‘½åçµ±ä¸€ãƒ»è²¬å‹™åˆ†é›¢ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆæœ€é©åŒ–
        
        **å‡ºåŠ›å½¢å¼:**
        - æœ€é©åŒ–ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰å…¨æ–‡
        - å¤‰æ›´ç‚¹ã®è©³ç´°èª¬æ˜
        - ã‚³ãƒ¼ãƒ‰çŸ­ç¸®ç‡
        - å‡¦ç†é€Ÿåº¦æ”¹å–„è¦‹è¾¼ã¿
        
        åˆ†æã§å•é¡Œãªã—ã¨ã•ã‚ŒãŸéƒ¨åˆ†ã¯å¤‰æ›´ã—ãªã„ã“ã¨ã€‚
        `;
            
            const optimizedResult = await this.callClaude(optimizationPrompt);
            const processingTime = Date.now() - startTime;
            
            this.optimizationLog.push({
              phase: 'optimization',
              file: filePath,
              processingTime,
              result: optimizedResult,
              timestamp: new Date().toISOString()
            });
            
            return optimizedResult;
          }
        
          async extractOptimizedCode(optimizedResult) {
            const codeBlocks = optimizedResult.match(/```[\s\S]*?```/g);
            if (!codeBlocks) return null;
            
            // æœ€åˆã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
            const code = codeBlocks[0].replace(/```[\w]*\n/, '').replace(/```$/, '');
            return code.trim();
          }
        
          async splitLargeFiles(content, baseName) {
            const maxSize = 50000; // 50KBåˆ¶é™
            if (content.length <= maxSize) return [{ name: baseName, content }];
            
            const parts = [];
            const chunks = Math.ceil(content.length / maxSize);
            
            for (let i = 0; i < chunks; i++) {
              const start = i * maxSize;
              const end = Math.min(start + maxSize, content.length);
              const chunk = content.slice(start, end);
              
              parts.push({
                name: `${baseName}_part${i + 1}`,
                content: `/* Claudeæœ€é©åŒ– - Part ${i + 1}/${chunks} */\n${chunk}`
              });
            }
            
            return parts;
          }
        
          async validateOptimization(originalPath, optimizedPath) {
            console.log(`ğŸ” æ¤œè¨¼é–‹å§‹: ${originalPath} vs ${optimizedPath}`);
            
            const validationPrompt = `
        ## å·®åˆ†è©•ä¾¡ã¨æ¤œè¨¼
        
        å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨æœ€é©åŒ–å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¯”è¼ƒã—ã€ä»¥ä¸‹ã‚’è©•ä¾¡ã—ã¦ãã ã•ã„ï¼š
        
        **è©•ä¾¡è¦³ç‚¹:**
        1. UI/UX: è¡¨ç¤ºãƒ»æ“ä½œã«å¤‰åŒ–ãŒãªã„ã‹
        2. è¡¨ç¤ºé€Ÿåº¦: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„åº¦
        3. å®‰å®šæ€§: ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿãƒªã‚¹ã‚¯ã®å¤‰åŒ–
        4. æ©Ÿèƒ½å†ç¾æ€§: å…ƒã®æ©Ÿèƒ½ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã‹
        
        **åˆ¤å®š:**
        - åˆæ ¼: æœ€é©åŒ–æˆåŠŸ
        - ä¸åˆæ ¼: å•é¡Œã‚ã‚Šï¼ˆç†ç”±ã‚’æ˜è¨˜ï¼‰
        
        ä¸åˆæ ¼ã®å ´åˆã¯ä¿®æ­£æ¡ˆã‚’æç¤ºã—ã¦ãã ã•ã„ã€‚
        `;
            
            const validation = await this.callClaude(validationPrompt);
            
            this.optimizationLog.push({
              phase: 'validation',
              originalFile: originalPath,
              optimizedFile: optimizedPath,
              result: validation,
              timestamp: new Date().toISOString()
            });
            
            return validation.includes('åˆæ ¼') || validation.includes('æˆåŠŸ');
          }
        
          async processFile(filePath) {
            if (this.processedFiles.has(filePath)) {
              console.log(`â­ï¸  ã‚¹ã‚­ãƒƒãƒ—æ¸ˆã¿: ${filePath}`);
              return;
            }
            
            try {
              // ã‚¹ãƒ†ãƒƒãƒ—1: è¨ºæ–­
              const analysis = await this.analyzeCode(filePath);
              
              // æœ€é©åŒ–ä¸è¦ã¨åˆ¤å®šã•ã‚ŒãŸå ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
              if (analysis.includes('æœ€é©åŒ–å¯¾è±¡: false') || analysis.includes('å•é¡Œãªã—')) {
                console.log(`âœ… æœ€é©åŒ–ä¸è¦: ${filePath}`);
                this.processedFiles.add(filePath);
                return;
              }
              
              // ã‚¹ãƒ†ãƒƒãƒ—2: æœ€é©åŒ–
              const optimizedResult = await this.optimizeCode(filePath, analysis);
              const optimizedCode = await this.extractOptimizedCode(optimizedResult);
              
              if (!optimizedCode) {
                console.log(`âŒ æœ€é©åŒ–å¤±æ•—: ${filePath}`);
                return;
              }
              
              // ã‚¹ãƒ†ãƒƒãƒ—3: ãƒ•ã‚¡ã‚¤ãƒ«åˆ†å‰²ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
              const baseName = path.basename(filePath, path.extname(filePath));
              const parts = await this.splitLargeFiles(optimizedCode, baseName);
              
              // ã‚¹ãƒ†ãƒƒãƒ—4: ä¿å­˜
              await fs.ensureDir(this.targetDir);
              const optimizedPath = path.join(this.targetDir, path.basename(filePath));
              
              if (parts.length === 1) {
                await fs.writeFile(optimizedPath, parts[0].content);
              } else {
                // è¤‡æ•°ãƒ‘ãƒ¼ãƒˆã«åˆ†å‰²
                for (const part of parts) {
                  const partPath = path.join(this.targetDir, `${part.name}${path.extname(filePath)}`);
                  await fs.writeFile(partPath, part.content);
                }
              }
              
              // ã‚¹ãƒ†ãƒƒãƒ—5: æ¤œè¨¼
              const isValid = await this.validateOptimization(filePath, optimizedPath);
              
              if (isValid) {
                console.log(`âœ… æœ€é©åŒ–å®Œäº†: ${filePath}`);
                this.processedFiles.add(filePath);
              } else {
                console.log(`âŒ æ¤œè¨¼å¤±æ•—: ${filePath}`);
                await fs.remove(optimizedPath);
              }
              
            } catch (error) {
              console.error(`âŒ å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${filePath}`, error.message);
              this.optimizationLog.push({
                phase: 'error',
                file: filePath,
                error: error.message,
                timestamp: new Date().toISOString()
              });
            }
          }
        
          async run() {
            console.log('ğŸš€ Claudeæœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ é–‹å§‹');
            
            // å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œå‡º
            const targetFiles = ['index.html'];
            const cssFiles = await fs.readdir('.').then(files => files.filter(f => f.endsWith('.css')));
            const jsFiles = await fs.readdir('.').then(files => files.filter(f => f.endsWith('.js')));
            
            targetFiles.push(...cssFiles, ...jsFiles);
            
            console.log(`ğŸ“ å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«: ${targetFiles.join(', ')}`);
            
            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é †æ¬¡å‡¦ç†
            for (const file of targetFiles) {
              if (await fs.pathExists(file)) {
                await this.processFile(file);
              }
            }
            
            // ãƒ­ã‚°å‡ºåŠ›
            await this.generateReport();
            
            console.log('ğŸ‰ æœ€é©åŒ–å‡¦ç†å®Œäº†');
          }
        
          async generateReport() {
            const report = {
              timestamp: new Date().toISOString(),
              totalFiles: this.processedFiles.size,
              processedFiles: Array.from(this.processedFiles),
              optimizationLog: this.optimizationLog,
              summary: {
                totalProcessingTime: this.optimizationLog.reduce((sum, log) => sum + (log.processingTime || 0), 0),
                successCount: this.optimizationLog.filter(log => log.phase === 'validation' && log.result.includes('åˆæ ¼')).length,
                errorCount: this.optimizationLog.filter(log => log.phase === 'error').length
              }
            };
            
            await fs.writeFile('optimization_report.json', JSON.stringify(report, null, 2));
            console.log('ğŸ“Š ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†: optimization_report.json');
          }
        }
        
        // å®Ÿè¡Œ
        async function main() {
          const optimizer = new ClaudeOptimizer();
          await optimizer.run();
        }
        
        main().catch(console.error);
        EOF
    
    - name: Run optimization
      run: |
        node optimize.js
        echo "ğŸ”„ æœ€é©åŒ–å®Ÿè¡Œå®Œäº†"
    
    - name: Commit optimized files
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # optimizedãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ã€å¤‰æ›´ãŒã‚ã‚‹å ´åˆã®ã¿ã‚³ãƒŸãƒƒãƒˆ
        if [ -d "optimized" ] && [ -n "$(git status --porcelain optimized/)" ]; then
          git add optimized/
          git add optimization_report.json
          
          # ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æœ€é©åŒ–æƒ…å ±ã‚’å«ã‚ã‚‹
          OPTIMIZED_COUNT=$(find optimized/ -type f | wc -l)
          git commit -m "ğŸš€ Claudeæœ€é©åŒ–å®Ÿè¡Œ: ${OPTIMIZED_COUNT}ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Œäº†
          
          - å‡¦ç†æ™‚é–“: $(date '+%Y-%m-%d %H:%M:%S')
          - æœ€é©åŒ–ãƒ•ã‚¡ã‚¤ãƒ«: ${OPTIMIZED_COUNT}å€‹
          - è©³ç´°: optimization_report.jsonå‚ç…§
          
          [skip ci]"
          
          git push
          echo "âœ… æœ€é©åŒ–çµæœã‚’ãƒ—ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ"
        else
          echo "â„¹ï¸ æœ€é©åŒ–å¯¾è±¡ãªã—ã€ã¾ãŸã¯å¤‰æ›´ãªã—"
        fi
    
    - name: Check optimization status
      run: |
        if [ -f "optimization_report.json" ]; then
          echo "ğŸ“‹ æœ€é©åŒ–ãƒ¬ãƒãƒ¼ãƒˆæ¦‚è¦:"
          cat optimization_report.json | jq '.summary'
        fi
        
        echo "ğŸ“ æœ€é©åŒ–ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§:"
        find optimized/ -type f 2>/dev/null | head -20 || echo "æœ€é©åŒ–ãƒ•ã‚¡ã‚¤ãƒ«ãªã—"
    
    - name: Cleanup old optimizations
      run: |
        # 7æ—¥ä»¥ä¸Šå‰ã®æœ€é©åŒ–ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
        find optimized/ -type f -mtime +7 -delete 2>/dev/null || true
        
        # ç©ºã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‰Šé™¤
        find optimized/ -type d -empty -delete 2>/dev/null || true
