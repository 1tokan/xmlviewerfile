name: Auto Optimize with Claude
on:
  schedule:
    - cron: '*/15 * * * *'  # 15分ごと実行
  workflow_dispatch:
  push:
    paths: ['index.html', '*.css', '*.js']

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  MAX_EXECUTION_DAYS: 30

jobs:
  optimize:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Check execution time limit
      id: time_check
      run: |
        START_TIME=$(git log --format=%ct -n 1 -- .github/workflows/auto_optimize_claude.yml 2>/dev/null || echo $(date +%s))
        CURRENT_TIME=$(date +%s)
        ELAPSED_DAYS=$(( (CURRENT_TIME - START_TIME) / 86400 ))
        
        if [ $ELAPSED_DAYS -gt $MAX_EXECUTION_DAYS ]; then
          echo "execution_expired=true" >> $GITHUB_OUTPUT
          echo "⏰ 最大実行期間($MAX_EXECUTION_DAYS日)を超過しました"
          exit 1
        fi
        echo "elapsed_days=$ELAPSED_DAYS" >> $GITHUB_OUTPUT
    
    - name: Install dependencies
      run: |
        npm init -y
        npm install axios cheerio fs-extra
    
    - name: Create optimization script
      run: |
        cat > optimize.js << 'EOF'
        const axios = require('axios');
        const cheerio = require('cheerio');
        const fs = require('fs-extra');
        const path = require('path');
        
        class ClaudeOptimizer {
          constructor() {
            this.apiKey = process.env.ANTHROPIC_API_KEY;
            this.baseUrl = 'https://api.anthropic.com/v1/messages';
            this.optimizationLog = [];
            this.processedFiles = new Set();
            this.targetDir = 'optimized';
            this.maxRetries = 3;
          }
        
          async callClaude(prompt, context = '') {
            const fullPrompt = `${context}\n\n${prompt}`;
            
            for (let i = 0; i < this.maxRetries; i++) {
              try {
                const response = await axios.post(this.baseUrl, {
                  model: 'claude-3-5-sonnet-20241022',
                  max_tokens: 8000,
                  temperature: 0.1,
                  system: `あなたは高度なWebパフォーマンス最適化専門家です。HTML/CSS/JavaScriptコードを分析し、具体的な問題点を特定して最適化を行います。処理速度・仕様完全網羅・文字数最小化を重視し、段階的な最適化を実施してください。`,
                  messages: [{ role: 'user', content: fullPrompt }]
                }, {
                  headers: {
                    'Authorization': `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                    'anthropic-version': '2023-06-01'
                  },
                  timeout: 30000
                });
                
                return response.data.content[0].text;
              } catch (error) {
                console.log(`Claude API呼び出し失敗 (試行 ${i + 1}/${this.maxRetries}):`, error.message);
                if (i === this.maxRetries - 1) throw error;
                await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
              }
            }
          }
        
          async analyzeCode(filePath) {
            const startTime = Date.now();
            const content = await fs.readFile(filePath, 'utf8');
            const fileType = path.extname(filePath);
            
            console.log(`📋 分析開始: ${filePath}`);
            
            const analysisPrompt = `
        ## コード診断フェーズ
        以下の${fileType}ファイルを分析し、問題点を特定してください：
        
        **ファイル名:** ${filePath}
        **内容:**
        \`\`\`${fileType.slice(1)}
        ${content}
        \`\`\`
        
        **分析観点:**
        1. 不適切・非効率な記述
        2. 重複・未使用コード
        3. UX/UIや処理速度に悪影響を与える記述
        4. 可読性・保守性の低い構成
        5. 設計原則に反する点
        
        **出力形式:**
        - 問題箇所: [行数] 具体的な問題点
        - 修正理由: なぜ修正が必要か
        - 最適化対象: true/false
        - 改善案: 具体的な修正方法
        
        問題のない部分は触らないこと。
        `;
            
            const analysis = await this.callClaude(analysisPrompt);
            const processingTime = Date.now() - startTime;
            
            this.optimizationLog.push({
              phase: 'analysis',
              file: filePath,
              processingTime,
              result: analysis,
              timestamp: new Date().toISOString()
            });
            
            return analysis;
          }
        
          async optimizeCode(filePath, analysisResult) {
            const startTime = Date.now();
            const content = await fs.readFile(filePath, 'utf8');
            const fileType = path.extname(filePath);
            
            console.log(`⚡ 最適化開始: ${filePath}`);
            
            const optimizationPrompt = `
        ## 最適化フェーズ
        
        **分析結果:**
        ${analysisResult}
        
        **元のコード:**
        \`\`\`${fileType.slice(1)}
        ${content}
        \`\`\`
        
        **最適化要件:**
        - 処理速度: DOM操作・再描画の抑制、ループやセレクタの見直し
        - コード簡素化: 冗長なロジック・未使用変数の削除
        - エラーハンドリング: try-catch導入、構文・文字コードエラー対処
        - 保守性: 命名統一・責務分離・コメント最適化
        
        **出力形式:**
        - 最適化されたコード全文
        - 変更点の詳細説明
        - コード短縮率
        - 処理速度改善見込み
        
        分析で問題なしとされた部分は変更しないこと。
        `;
            
            const optimizedResult = await this.callClaude(optimizationPrompt);
            const processingTime = Date.now() - startTime;
            
            this.optimizationLog.push({
              phase: 'optimization',
              file: filePath,
              processingTime,
              result: optimizedResult,
              timestamp: new Date().toISOString()
            });
            
            return optimizedResult;
          }
        
          async extractOptimizedCode(optimizedResult) {
            const codeBlocks = optimizedResult.match(/```[\s\S]*?```/g);
            if (!codeBlocks) return null;
            
            // 最初のコードブロックを抽出
            const code = codeBlocks[0].replace(/```[\w]*\n/, '').replace(/```$/, '');
            return code.trim();
          }
        
          async splitLargeFiles(content, baseName) {
            const maxSize = 50000; // 50KB制限
            if (content.length <= maxSize) return [{ name: baseName, content }];
            
            const parts = [];
            const chunks = Math.ceil(content.length / maxSize);
            
            for (let i = 0; i < chunks; i++) {
              const start = i * maxSize;
              const end = Math.min(start + maxSize, content.length);
              const chunk = content.slice(start, end);
              
              parts.push({
                name: `${baseName}_part${i + 1}`,
                content: `/* Claude最適化 - Part ${i + 1}/${chunks} */\n${chunk}`
              });
            }
            
            return parts;
          }
        
          async validateOptimization(originalPath, optimizedPath) {
            console.log(`🔍 検証開始: ${originalPath} vs ${optimizedPath}`);
            
            const validationPrompt = `
        ## 差分評価と検証
        
        元のファイルと最適化後のファイルを比較し、以下を評価してください：
        
        **評価観点:**
        1. UI/UX: 表示・操作に変化がないか
        2. 表示速度: パフォーマンス改善度
        3. 安定性: エラー発生リスクの変化
        4. 機能再現性: 元の機能が正しく動作するか
        
        **判定:**
        - 合格: 最適化成功
        - 不合格: 問題あり（理由を明記）
        
        不合格の場合は修正案を提示してください。
        `;
            
            const validation = await this.callClaude(validationPrompt);
            
            this.optimizationLog.push({
              phase: 'validation',
              originalFile: originalPath,
              optimizedFile: optimizedPath,
              result: validation,
              timestamp: new Date().toISOString()
            });
            
            return validation.includes('合格') || validation.includes('成功');
          }
        
          async processFile(filePath) {
            if (this.processedFiles.has(filePath)) {
              console.log(`⏭️  スキップ済み: ${filePath}`);
              return;
            }
            
            try {
              // ステップ1: 診断
              const analysis = await this.analyzeCode(filePath);
              
              // 最適化不要と判定された場合はスキップ
              if (analysis.includes('最適化対象: false') || analysis.includes('問題なし')) {
                console.log(`✅ 最適化不要: ${filePath}`);
                this.processedFiles.add(filePath);
                return;
              }
              
              // ステップ2: 最適化
              const optimizedResult = await this.optimizeCode(filePath, analysis);
              const optimizedCode = await this.extractOptimizedCode(optimizedResult);
              
              if (!optimizedCode) {
                console.log(`❌ 最適化失敗: ${filePath}`);
                return;
              }
              
              // ステップ3: ファイル分割（必要に応じて）
              const baseName = path.basename(filePath, path.extname(filePath));
              const parts = await this.splitLargeFiles(optimizedCode, baseName);
              
              // ステップ4: 保存
              await fs.ensureDir(this.targetDir);
              const optimizedPath = path.join(this.targetDir, path.basename(filePath));
              
              if (parts.length === 1) {
                await fs.writeFile(optimizedPath, parts[0].content);
              } else {
                // 複数パートに分割
                for (const part of parts) {
                  const partPath = path.join(this.targetDir, `${part.name}${path.extname(filePath)}`);
                  await fs.writeFile(partPath, part.content);
                }
              }
              
              // ステップ5: 検証
              const isValid = await this.validateOptimization(filePath, optimizedPath);
              
              if (isValid) {
                console.log(`✅ 最適化完了: ${filePath}`);
                this.processedFiles.add(filePath);
              } else {
                console.log(`❌ 検証失敗: ${filePath}`);
                await fs.remove(optimizedPath);
              }
              
            } catch (error) {
              console.error(`❌ 処理エラー: ${filePath}`, error.message);
              this.optimizationLog.push({
                phase: 'error',
                file: filePath,
                error: error.message,
                timestamp: new Date().toISOString()
              });
            }
          }
        
          async run() {
            console.log('🚀 Claude最適化システム開始');
            
            // 対象ファイルの検出
            const targetFiles = ['index.html'];
            const cssFiles = await fs.readdir('.').then(files => files.filter(f => f.endsWith('.css')));
            const jsFiles = await fs.readdir('.').then(files => files.filter(f => f.endsWith('.js')));
            
            targetFiles.push(...cssFiles, ...jsFiles);
            
            console.log(`📁 対象ファイル: ${targetFiles.join(', ')}`);
            
            // 各ファイルを順次処理
            for (const file of targetFiles) {
              if (await fs.pathExists(file)) {
                await this.processFile(file);
              }
            }
            
            // ログ出力
            await this.generateReport();
            
            console.log('🎉 最適化処理完了');
          }
        
          async generateReport() {
            const report = {
              timestamp: new Date().toISOString(),
              totalFiles: this.processedFiles.size,
              processedFiles: Array.from(this.processedFiles),
              optimizationLog: this.optimizationLog,
              summary: {
                totalProcessingTime: this.optimizationLog.reduce((sum, log) => sum + (log.processingTime || 0), 0),
                successCount: this.optimizationLog.filter(log => log.phase === 'validation' && log.result.includes('合格')).length,
                errorCount: this.optimizationLog.filter(log => log.phase === 'error').length
              }
            };
            
            await fs.writeFile('optimization_report.json', JSON.stringify(report, null, 2));
            console.log('📊 レポート生成完了: optimization_report.json');
          }
        }
        
        // 実行
        async function main() {
          const optimizer = new ClaudeOptimizer();
          await optimizer.run();
        }
        
        main().catch(console.error);
        EOF
    
    - name: Run optimization
      run: |
        node optimize.js
        echo "🔄 最適化実行完了"
    
    - name: Commit optimized files
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # optimizedディレクトリが存在し、変更がある場合のみコミット
        if [ -d "optimized" ] && [ -n "$(git status --porcelain optimized/)" ]; then
          git add optimized/
          git add optimization_report.json
          
          # コミットメッセージに最適化情報を含める
          OPTIMIZED_COUNT=$(find optimized/ -type f | wc -l)
          git commit -m "🚀 Claude最適化実行: ${OPTIMIZED_COUNT}ファイル処理完了
          
          - 処理時間: $(date '+%Y-%m-%d %H:%M:%S')
          - 最適化ファイル: ${OPTIMIZED_COUNT}個
          - 詳細: optimization_report.json参照
          
          [skip ci]"
          
          git push
          echo "✅ 最適化結果をプッシュしました"
        else
          echo "ℹ️ 最適化対象なし、または変更なし"
        fi
    
    - name: Check optimization status
      run: |
        if [ -f "optimization_report.json" ]; then
          echo "📋 最適化レポート概要:"
          cat optimization_report.json | jq '.summary'
        fi
        
        echo "📁 最適化ファイル一覧:"
        find optimized/ -type f 2>/dev/null | head -20 || echo "最適化ファイルなし"
    
    - name: Cleanup old optimizations
      run: |
        # 7日以上前の最適化ファイルを削除
        find optimized/ -type f -mtime +7 -delete 2>/dev/null || true
        
        # 空のディレクトリを削除
        find optimized/ -type d -empty -delete 2>/dev/null || true
