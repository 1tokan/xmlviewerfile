name: Claude XML Viewer Optimizer
on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:
  push:
    paths: ['index.html', '*.css', '*.js']
env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  MAX_DAYS: 30
  TARGET_REPO: 1tokan/xmlviewerfile
  TEST_FOLDER: CALS_EC
jobs:
  optimize:
    runs-on: ubuntu-latest
    timeout-minutes: 14
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    - uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
    - name: Time Guard
      run: |
        S=$(git log --format=%ct -n 1 -- .github/workflows/auto_optimize_claude.yml 2>/dev/null || echo $(date +%s))
        [ $(( ($(date +%s) - S) / 86400 )) -gt $MAX_DAYS ] && exit 1 || echo "✅ Time OK"
    - name: Setup
      run: |
        npm init -y --type=module
        npm i axios cheerio fs-extra
    - name: Generate Optimizer
      run: |
        cat > opt.js << 'EOF'
        import axios from 'axios';
        import * as cheerio from 'cheerio';
        import fs from 'fs-extra';
        import path from 'path';
        
        const API='https://api.anthropic.com/v1/messages',MODEL='claude-3-5-sonnet-20241022',MAX_TOKENS=8000,TEMP=0.1,RETRIES=3,TIMEOUT=25000;
        const SYSTEM=`XML Viewer最適化専門家として、HTML/CSS/JS構造を段階的に分析・診断・最適化します。処理速度・仕様完全網羅・文字数最小化を重視し、問題点のみを特定・修正してください。`;
        
        class ClaudeOpt {
          constructor() {
            this.key = process.env.ANTHROPIC_API_KEY;
            this.log = [];
            this.processed = new Set();
            this.outDir = 'optimized';
            this.baseUrl = 'https://1tokan.github.io/xmlviewerfile';
            this.testUrl = 'https://1tokan.github.io/CALS_EC';
          }
        
          async claude(prompt, ctx = '') {
            const full = `${ctx}\n\n${prompt}`;
            for (let i = 0; i < RETRIES; i++) {
              try {
                const res = await axios.post(API, {
                  model: MODEL,
                  max_tokens: MAX_TOKENS,
                  temperature: TEMP,
                  system: SYSTEM,
                  messages: [{ role: 'user', content: full }]
                }, {
                  headers: {
                    'Authorization': `Bearer ${this.key}`,
                    'Content-Type': 'application/json',
                    'anthropic-version': '2023-06-01'
                  },
                  timeout: TIMEOUT
                });
                return res.data.content[0].text;
              } catch (e) {
                console.log(`🔄 Retry ${i + 1}/${RETRIES}: ${e.message}`);
                if (i === RETRIES - 1) throw e;
                await new Promise(r => setTimeout(r, 1000 * (i + 1)));
              }
            }
          }
        
          async analyze(file) {
            const start = Date.now();
            const content = await fs.readFile(file, 'utf8');
            const ext = path.extname(file);
            
            console.log(`📋 分析: ${file}`);
            
            const prompt = `
        ## 🔍 XML Viewer診断フェーズ
        
        **対象:** ${file}
        **構造:** HTML/CSS/JS統合型XMLビューワー
        **用途:** ${this.testUrl}のXMLファイル読み込み表示
        
        \`\`\`${ext.slice(1)}
        ${content}
        \`\`\`
        
        **診断観点:**
        1. 🚨 致命的問題: 構文エラー、メモリリーク、無限ループ
        2. ⚡ 速度問題: DOM操作、再描画、重いループ、非効率セレクタ
        3. 🔄 冗長性: 重複コード、未使用変数/関数、無駄な処理
        4. 🛡️ エラー処理: XMLパース失敗、ファイル読み込み失敗対応
        5. 📐 設計問題: 責務混在、保守性低下、命名不統一
        
        **出力形式:**
        - 問題箇所: [L行数] 具体的問題
        - 影響度: 致命的/重要/軽微
        - 修正必要: true/false
        - 改善案: 具体的修正方法
        
        **重要:** 問題なし部分は触らない、XMLファイル内容は対象外
        `;
            
            const result = await this.claude(prompt);
            const time = Date.now() - start;
            
            this.log.push({
              phase: 'analyze',
              file,
              time,
              result,
              timestamp: new Date().toISOString()
            });
            
            return result;
          }
        
          async optimize(file, analysis) {
            const start = Date.now();
            const content = await fs.readFile(file, 'utf8');
            const ext = path.extname(file);
            
            console.log(`⚡ 最適化: ${file}`);
            
            const prompt = `
        ## 🚀 最適化フェーズ
        
        **分析結果:**
        ${analysis}
        
        **元コード:**
        \`\`\`${ext.slice(1)}
        ${content}
        \`\`\`
        
        **最適化要件:**
        - 🎯 処理速度: DOM操作最小化、効率的セレクタ、再描画抑制
        - 📦 コード圧縮: 冗長削除、変数統合、関数最適化
        - 🔧 機能分割: xmlParser.js, errorHandler.js, uiController.js
        - 🛡️ エラー処理: try-catch追加、XML構文エラー対応
        - 📝 保守性: 命名統一、コメント最適化、責務分離
        
        **出力:**
        1. 最適化コード全文
        2. 変更点詳細
        3. 圧縮率
        4. 速度改善見込み
        
        **制約:** 分析で問題なし = 変更禁止、純粋バニラJS、機能単位分割
        `;
            
            const result = await this.claude(prompt);
            const time = Date.now() - start;
            
            this.log.push({
              phase: 'optimize',
              file,
              time,
              result,
              timestamp: new Date().toISOString()
            });
            
            return result;
          }
        
          extractCode(text) {
            const blocks = text.match(/```[\s\S]*?```/g);
            if (!blocks) return null;
            return blocks[0].replace(/```[\w]*\n/, '').replace(/```$/, '').trim();
          }
        
          async split(content, base) {
            const max = 49152; // 48KB
            if (content.length <= max) return [{ name: base, content }];
            
            const parts = [];
            const chunks = Math.ceil(content.length / max);
            
            for (let i = 0; i < chunks; i++) {
              const start = i * max;
              const end = Math.min(start + max, content.length);
              parts.push({
                name: `${base}_part${i + 1}of${chunks}`,
                content: `/* 🤖 Claude最適化 Part ${i + 1}/${chunks} */\n${content.slice(start, end)}`
              });
            }
            return parts;
          }
        
          async validate(orig, opt) {
            console.log(`🔍 検証: ${orig} vs ${opt}`);
            
            const prompt = `
        ## 🧪 差分評価・検証フェーズ
        
        **比較対象:**
        - 元: ${orig}
        - 最適化後: ${opt}
        
        **検証観点:**
        1. 🎨 UI/UX: 表示崩れ、操作性変化
        2. ⚡ 速度: パフォーマンス改善度
        3. 🛡️ 安定性: エラー発生リスク
        4. 🔄 機能性: XML読み込み・表示機能
        5. 📱 互換性: ブラウザ対応
        
        **判定基準:**
        - ✅ 合格: UI正常 + 速度改善 + 機能維持
        - ❌ 不合格: UI崩れ or 機能劣化 or エラー増加
        
        **出力:** 合格/不合格 + 理由 + 修正案（不合格時）
        `;
            
            const result = await this.claude(prompt);
            
            this.log.push({
              phase: 'validate',
              orig,
              opt,
              result,
              timestamp: new Date().toISOString()
            });
            
            return result.includes('✅') || result.includes('合格');
          }
        
          async process(file) {
            if (this.processed.has(file)) {
              console.log(`⏭️ Skip: ${file}`);
              return;
            }
            
            try {
              const analysis = await this.analyze(file);
              
              if (analysis.includes('修正必要: false') || analysis.includes('問題なし')) {
                console.log(`✅ 最適化不要: ${file}`);
                this.processed.add(file);
                return;
              }
              
              const optimized = await this.optimize(file, analysis);
              const code = this.extractCode(optimized);
              
              if (!code) {
                console.log(`❌ 最適化失敗: ${file}`);
                return;
              }
              
              const base = path.basename(file, path.extname(file));
              const parts = await this.split(code, base);
              
              await fs.ensureDir(this.outDir);
              const outPath = path.join(this.outDir, path.basename(file));
              
              if (parts.length === 1) {
                await fs.writeFile(outPath, parts[0].content);
              } else {
                for (const part of parts) {
                  const partPath = path.join(this.outDir, `${part.name}${path.extname(file)}`);
                  await fs.writeFile(partPath, part.content);
                }
              }
              
              const valid = await this.validate(file, outPath);
              
              if (valid) {
                console.log(`✅ 完了: ${file}`);
                this.processed.add(file);
              } else {
                console.log(`❌ 検証失敗: ${file}`);
                await fs.remove(outPath);
              }
              
            } catch (e) {
              console.error(`❌ Error: ${file}`, e.message);
              this.log.push({
                phase: 'error',
                file,
                error: e.message,
                timestamp: new Date().toISOString()
              });
            }
          }
        
          async run() {
            console.log('🚀 Claude XML Viewer Optimizer v2.0');
            
            const files = ['index.html'];
            
            try {
              const all = await fs.readdir('.');
              files.push(
                ...all.filter(f => f.endsWith('.css')),
                ...all.filter(f => f.endsWith('.js') && f !== 'opt.js')
              );
            } catch (e) {
              console.error('File scan error:', e.message);
            }
            
            console.log(`📁 対象: ${files.join(', ')}`);
            
            for (const file of files) {
              try {
                if (await fs.pathExists(file)) {
                  await this.process(file);
                }
              } catch (e) {
                console.error(`Process error: ${file}`, e.message);
              }
            }
            
            await this.report();
            console.log('🎉 最適化完了');
          }
        
          async report() {
            const report = {
              timestamp: new Date().toISOString(),
              target: this.baseUrl,
              testFolder: this.testUrl,
              totalFiles: this.processed.size,
              processedFiles: Array.from(this.processed),
              optimizationLog: this.log,
              summary: {
                totalTime: this.log.reduce((s, l) => s + (l.time || 0), 0),
                successCount: this.log.filter(l => l.phase === 'validate' && l.result.includes('✅')).length,
                errorCount: this.log.filter(l => l.phase === 'error').length,
                compressionRate: this.log.filter(l => l.phase === 'optimize').length > 0 ? '計算中' : '0%'
              }
            };
            
            await fs.writeFile('optimization_report.json', JSON.stringify(report, null, 2));
            console.log('📊 Report: optimization_report.json');
          }
        }
        
        new ClaudeOpt().run().catch(console.error);
        EOF
    - name: Execute Optimization
      run: |
        node opt.js
        echo "🔄 最適化実行完了"
    - name: Deploy Results
      run: |
        git config --local user.email "claude@optimizer.ai"
        git config --local user.name "Claude Optimizer"
        
        if [ -d "optimized" ] && [ -n "$(git status --porcelain optimized/)" ]; then
          git add optimized/ optimization_report.json
          
          COUNT=$(find optimized/ -type f | wc -l)
          SIZE=$(du -sh optimized/ | cut -f1)
          
          git commit -m "🚀 Claude最適化実行 [$(date '+%m/%d %H:%M')]
          
          📊 処理結果:
          - 最適化ファイル: ${COUNT}個 (${SIZE})
          - 対象サイト: https://1tokan.github.io/xmlviewerfile
          - テストフォルダ: https://1tokan.github.io/CALS_EC
          - 詳細レポート: optimization_report.json
          
          🎯 最適化観点: 速度向上・コード圧縮・エラー処理・保守性
          
          [skip ci]"
          
          git push
          echo "✅ 最適化結果プッシュ完了"
        else
          echo "ℹ️ 最適化対象なし"
        fi
    - name: Status Report
      run: |
        if [ -f "optimization_report.json" ]; then
          echo "📋 最適化サマリー:"
          cat optimization_report.json | jq -r '.summary | to_entries[] | "\(.key): \(.value)"'
          echo ""
          echo "📁 最適化ファイル:"
          cat optimization_report.json | jq -r '.processedFiles[]?' | head -10
        fi
        
        echo ""
        echo "🌐 デプロイ先:"
        echo "- メイン: https://1tokan.github.io/xmlviewerfile"
        echo "- 最適化版: https://1tokan.github.io/optimized"
        echo "- テスト用XML: https://1tokan.github.io/CALS_EC"
    - name: Cleanup
      run: |
        find optimized/ -type f -mtime +7 -delete 2>/dev/null || true
        find optimized/ -type d -empty -delete 2>/dev/null || true
        echo "🧹 古いファイル削除完了"
